buildscript {
  repositories {
    mavenLocal()
    if (project.hasProperty('localNexus')) {
      maven {
        url "${localNexus}"
        allowInsecureProtocol true
      }
    } else {
      mavenCentral()
    }
  }

  dependencies {
    classpath libs.fincher.gradle.release
    classpath libs.fincher.sonarlint
  }
}

plugins {
  id 'java-gradle-plugin'
  id 'maven-publish'
  id 'eclipse'
}

apply plugin: 'com.fincher.release'
apply plugin: 'com.fincher.sonarlint'

group = 'com.fincher'

gradlePlugin {
  plugins {
    checkstyle {
      id = "com.fincher.java.checkstyle"
      implementationClass = "com.fincher.gradle.checkstyle.CheckstyleConfigPlugin"
    }
		
    eclipse {
      id = "com.fincher.java.eclipse"
      implementationClass = "com.fincher.gradle.eclipse.EclipseSettings"
     }
     
     gradleBase {
       id = "com.fincher.gradle.base"
       implementationClass = "com.fincher.gradle.base.FincherBasePlugin"
     }
     
     javaBase {
       id = "com.fincher.java"
       implementationClass = "com.fincher.gradle.base.FincherJavaPlugin"
     }
  }
}

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(11)
  }
}

release {
  if (project.hasProperty('sshKeyFile')) {
    gitRepositorySshPrivateKeyFile = file("${sshKeyFile}")
  }
}
	
sourceSets {
  functionalTest {
    java {
      compileClasspath += main.output
      runtimeClasspath += main.output
    }
  }
}

repositories {
  mavenLocal()
  if (project.hasProperty('localNexus')) {
    maven {
      url "${localNexus}"
      allowInsecureProtocol true
    }
  } else {
    mavenCentral()
  }
}
	
publishing {
  repositories {
    maven {
      if (project.hasProperty("publishUsername") && project.hasProperty("publishPassword")) { 
        credentials {
          username = "${publishUsername}"
          password = "${publishPassword}"
        }
		
        if (project.version.endsWith('-SNAPSHOT')) {
          url "${publishSnapshotUrl}"
        } else {         
          url "${publishReleaseUrl}"
        }    
        allowInsecureProtocol true

        authentication {
          basic(BasicAuthentication)
        }

        allowInsecureProtocol = true
      }
    }
  }
}
    
configurations.functionalTestImplementation.extendsFrom(configurations.testImplementation)

dependencies {
  implementation libs.spotless.plugin.gradle
  implementation libs.velocity
  api libs.fincher.sonarlint
  testImplementation libs.junit5.api
  testRuntimeOnly libs.junit5.engine
  functionalTestImplementation libs.junit5.params
  functionalTestRuntimeOnly libs.junit5.engine
}

tasks.register('functionalTest', Test) {
  testClassesDirs = sourceSets.functionalTest.output.classesDirs
  classpath = sourceSets.functionalTest.runtimeClasspath
  useJUnitPlatform()
}

gradlePlugin.testSourceSets(sourceSets.functionalTest)

tasks.named('sonarlintFunctionalTest') {
  enabled = false
}

sonarlint {
  reports {
    html { enabled = true }
  }
}
tasks.named('check') {
  dependsOn(tasks.functionalTest)
}

tasks.named('test') {
  useJUnitPlatform()
}
    
eclipse {
  classpath {
    downloadSources=true
    downloadJavadoc=true
  }
}

plugins.withType(EclipsePlugin) {
    plugins.withType(JavaBasePlugin) {
        eclipse {
            classpath {
                file {
                    whenMerged { classpath ->
                        String gradleHome = gradle.getGradleHomeDir()
                            .absolutePath
                            .replace(File.separator, '/')
                        String gradleSourceDirectory = "${gradleHome}/src"
                        classpath.entries.each { entry ->
                            if (entry in org.gradle.plugins.ide.eclipse.model.AbstractLibrary
                                    && entry.library.path.contains('generated-gradle-jars')) {
                                entry.sourcePath =
                                    new org.gradle.plugins.ide.eclipse.model.internal.FileReferenceFactory()
                                        .fromPath(gradleSourceDirectory)
                            }
                        }
                    }
                }
            }
        }
    }
}

tasks.named('wrapper') {
    distributionType = Wrapper.DistributionType.ALL
    distributionBase
}
