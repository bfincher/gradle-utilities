/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.fincher.gradle.release;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;

import org.eclipse.jgit.api.AddCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.lib.Ref;
import org.gradle.testkit.runner.GradleRunner;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

/**
 * A simple functional test for the 'testPlugin.greeting' plugin.
 */
class TestReleasePluginFunctionalTest {

	private Path projectDir;

	private Path gitRepoDir;

	private Path buildFile;

	private Path settingsFile;

	private Path gradlePropertiesFile;

	private Path versionFile;

	private Path gitRepoBareDir;

	private GradleRunner runner;

	private List<String> runnerArguments;

	private String versionKeyValue;

	private Git git;

	@BeforeEach
	public void beforeEach() throws Exception {
		projectDir = recursivelyDeleteDir(Paths.get("build", "testProjectDir"));
		gitRepoBareDir = createEmptyDir(Paths.get("build", "testGitBare"));
		gitRepoDir = projectDir;
		buildFile = projectDir.resolve("build.gradle");
		settingsFile = projectDir.resolve("settings.gradle");
		gradlePropertiesFile = projectDir.resolve("gradle.properties");
		versionFile = gradlePropertiesFile;
		git = initGit();

		runnerArguments = new ArrayList<>();
		runnerArguments.add("-s");

		runner = GradleRunner.create();
		runner.forwardOutput();
		runner.withPluginClasspath();
		runner.withProjectDir(projectDir.toFile());

		versionKeyValue = "version";

		Files.writeString(settingsFile, "");
		Files.writeString(buildFile, "plugins {" + "  id('fincher.release')" + "}");
		Files.writeString(gradlePropertiesFile, versionKeyValue + " = 0.0.1-SNAPSHOT");

		gitAddInitialFiles(git);
	}

	@Test
	void testMajorRelease() throws IOException, GitAPIException {
		runnerArguments.add("prepareRelease");
		runnerArguments.add("--releaseType");
		runnerArguments.add("MAJOR");

		runner.withArguments(runnerArguments).build();

		verifyPrepareReleaseResults("1.0.0");
	}

	@Test
	void testMinorRelease() throws IOException, GitAPIException {
		runnerArguments.add("prepareRelease");
		runnerArguments.add("--releaseType");
		runnerArguments.add("MINOR");

		runner.withArguments(runnerArguments).build();

		verifyPrepareReleaseResults("0.1.0");
	}

	@Test
	void testPatchRelease() throws IOException, GitAPIException {
		runnerArguments.add("prepareRelease");
		runnerArguments.add("--releaseType");
		runnerArguments.add("PATCH");

		runner.withArguments(runnerArguments).build();

		verifyPrepareReleaseResults("0.0.2");
	}

	@Test
	void testVersionFileOverride() throws IOException, GitAPIException {

		versionFile = buildFile;

		Files.write(buildFile, Lists.newArrayList("plugins {", "  id('fincher.release')", "}", "", "release {",
				"    versionFile = file('build.gradle')", "}", "", "version='0.0.1'"));

		gitAddAndCommit(versionFile.getFileName().toString(), "update build.gradle to have version");

		runnerArguments.add("prepareRelease");
		runnerArguments.add("--releaseType");
		runnerArguments.add("MAJOR");

		runner.withArguments(runnerArguments).build();

		String originalVersion = getVersionFromFile();

		verifyPrepareReleaseResults("1.0.0");
	}

	private void verifyPrepareReleaseResults(String expectedVersion) throws IOException, GitAPIException {
		String version = getVersionFromFile();
		assertEquals(expectedVersion, version);
		assertEquals(String.format("\"Set version for release to %s\"", expectedVersion),
				git.log().call().iterator().next().getFullMessage());
		AbstractReleaseTask.verifyNoUncommitedChanges(git);

		Ref latestTag = git.tagList().call().iterator().next();
		assertNotNull(latestTag);
		assertEquals("refs/tags/" + expectedVersion, latestTag.getName());
	}

	private String getVersionFromFile() throws IOException {
		return VersionFile.load(versionFile, versionKeyValue).toString();
	}

	private Git initGit() throws IOException, GitAPIException {
		Git.init().setDirectory(gitRepoBareDir.toFile()).setBare(true).call();

		Git git = Git.cloneRepository().setURI(gitRepoBareDir.toUri().toString()).setDirectory(gitRepoDir.toFile())
				.call();

		return git;
	}

	private void gitAddInitialFiles(Git git) throws IOException, GitAPIException {

		Set<String> filesToAdd = Sets.newHashSet("build.gradle", "settings.gradle");
		filesToAdd.add(versionFile.getFileName().toString());

		AddCommand addCommand = git.add();
		filesToAdd.forEach(addCommand::addFilepattern);
		addCommand.call();

		git.commit().setMessage("initial commit").call();
	}

	private void gitAddAndCommit(String file, String message) throws GitAPIException {
		git.add().addFilepattern(file).call();
		git.commit().setMessage(message).call();
	}

	private static Path recursivelyDeleteDir(Path dir) throws IOException {
		if (Files.exists(dir)) {
			Files.walk(dir).sorted(Comparator.reverseOrder()).map(Path::toFile).forEach(File::delete);
		}
		return dir;
	}

	/** Create the given directory. If it previously exists, delete and re-create */
	private static Path createEmptyDir(Path dir) throws IOException {
		recursivelyDeleteDir(dir);
		Files.createDirectories(dir);
		return dir;
	}

}
